#!/usr/bin/env python

import rospy
#from point_in_polygon import *
from gazebo_msgs.srv import GetWorldProperties, GetModelProperties, GetModelState
import matplotlib as mp
import matplotlib.pyplot as plt
from math import *
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from gazebo_ros.gazebo_interface import spawn_sdf_model_client
#from gazebo_msgs.srv import *
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SetModelState

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from gazebo_msgs.srv import ApplyBodyWrench
from geometry_msgs.msg import Wrench
from rotation import *
from math import *

entertrainer_name = "turtlebot3"
ball_name = "tennis_ball"
debug_ball = False
debug_launcher = True
debug_position = False

class BasicEntertrainerController(object):

    def __init__(self, rate=0):
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)

        print("Creating object Basic Controller")
        if(rate != 0):
            rospy.init_node('entertrainer_test', log_level=rospy.INFO)

        self.get_world_properties = None
        self.get_model_properties = None
        self.get_model_state = None
        self.set_model_state = None
        self.apply_force = None

        self.cnt = 0
        self.launch_ball = False
        self.in_launcher = True
        self.ball_last_position = None
        self.ball_current_position = None

        self.objects = {}
        if(rate != 0):
            update_timer = rospy.Timer(rospy.Duration(rate), self.basic_movement)

    def get_proxy_handles(self):
        if self.get_world_properties is None:
            try:
                # Handle for world properties update function
                rospy.wait_for_service('/gazebo/get_world_properties', timeout=2)
                self.get_world_properties = rospy.ServiceProxy('/gazebo/get_world_properties', GetWorldProperties)
            except rospy.ROSException:
                print('/gazebo/get_world_properties service is unavailable')
        if self.get_model_properties is None:
            try:
                # Handle for retrieving model properties
                rospy.wait_for_service('/gazebo/get_model_properties',timeout=0.1)
                self.get_model_properties = rospy.ServiceProxy('/gazebo/get_model_properties', GetModelProperties)
            except rospy.ROSException:
                print('/gazebo/get_model_properties service is unavailable')
        if self.get_model_state is None:
            try:
               # Handle for retrieving model properties
                rospy.wait_for_service('/gazebo/get_joint_properties',timeout=0.1)
                self.get_model_state = rospy.ServiceProxy('/gazebo/get_model_state', GetModelState)
            except rospy.ROSException:
                print('/gazebo/get_model_properties service is unavailable')

        if self.set_model_state is None:
            try:
                rospy.wait_for_service('/gazebo/set_model_state',timeout=0.1)
                self.set_model_state = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)
            except rospy.ROSException:
                print('/gazebo/set_model_state service is unavailable')

        if self.apply_force is None:
            try:
                rospy.wait_for_service('/gazebo/apply_body_wrench',timeout=0.1)
                self.apply_force = rospy.ServiceProxy('/gazebo/apply_body_wrench', ApplyBodyWrench)
            except rospy.ROSException:
                print('/gazebo/set_model_state service is unavailable')


    def transform_robot_to_world_frame(self, robot_pose, vector_value):
        # vector_value is x, y, z in robot frame
        if(debug_launcher): print('Setting up the Launch Force')
        if(debug_launcher): print('\tQuanternion =',robot_pose.x, robot_pose.y, robot_pose.y, robot_pose.w)
        txyz = euler_from_quaternion(robot_pose)

        tx = txyz[0]
        ty = txyz[1]
        tz = txyz[2]
        if(debug_launcher): print('\tEuler =', tx, ty, tz)
        x = vector_value[0]
        y = vector_value[1]
        z = vector_value[2]
        if(debug_launcher): print('\tForce (robot) =', x, y, z)
        #[x1, y1, z1] = rzyx(tx, ty, tz, x, y, z)
        #print('\tForce (world) 1=', x1, y1, z1)
        #[x2, y2, z2] = ryzx(tx, ty, tz, x, y, z)
        #print('\tForce (world) 2=', x2, y2, z2)
        [x3, y3, z3] = rxyz(tx, ty, tz, x, y, z)
        #print('\tForce (world) 3=', x3, y3, z3)
        #[x4, y4, z4] = rzxy(tx, ty, tz, x, y, z)
        #print('\tForce (world) 4=', x4, y4, z4)
        #[x5, y5, z5] = ryxz(tx, ty, tz, x, y, z)
        #print('\tForce (world) 5=', x5, y5, z5)
        #[x6, y6, z6] = rxzy(tx, ty, tz, x, y, z)
        #print('\tForce (world) 6=', x6, y6, z6)


        [x, y, z] = [x3, y3, z3]
        if(debug_launcher): print('\tForce (world) =', x, y, z)
        return [x, y, z]

    def activate_launcher(self, robot_twist, force_n):
        #print(robot_twist)
        # Ball launcher angle
        angle_deg = 45
        angle_rad = radians(angle_deg)
        # Ball Launch relative to robot
        robot_x = force_n * cos(angle_rad)
        robot_z = force_n * sin(angle_rad)
        robot_y = force_n * 0
        # Ball Launch relative to Gazebo world
        ball_launch_vector = [robot_x, robot_y, robot_z]
        [x,y,z] = self.transform_robot_to_world_frame(robot_twist, ball_launch_vector)

        wrench          = Wrench()
        wrench.force.x  = x
        wrench.force.y  = y
        wrench.force.z  = z
        wrench.torque.x = 0
        wrench.torque.y = 0
        wrench.torque.z = 0
        # You can also define the start time if necessary...
        self.apply_force(body_name = "ball_body",wrench = wrench, duration = rospy.Duration(0.1)) # try to apply that as an instance...? Looks like it defaults to frame step
        if(debug_launcher): print('Ball force Applied')

    def basic_movement(self, event=None):
        self.get_proxy_handles()

        _position = None
        _twist = None
        _pose = None

        try:
            msg_world = self.get_world_properties()
            if(msg_world.success):
#                for model in msg_world.model_names:
#                    rospy.loginfo('Model ='+ str(model))
                model_properties = self.get_model_properties(entertrainer_name)
                if(model_properties.success):
                    model_state = self.get_model_state(entertrainer_name, "")
                    if(model_state.success):
                        _pose = model_state.pose
                        _position = model_state.pose.position
                        _twist = model_state.pose.orientation
                        if(debug_position): rospy.loginfo('Position ='+ str(_position.x) +' '+ str(_position.y) +' '+ str( _position.z))
                        if(debug_launcher): rospy.loginfo('Ball Launch Flag =' + str(self.launch_ball) + ', in launcher ='+ str(self.in_launcher) + ', counter=' + str(self.cnt))
                        if(self.launch_ball):
                            if(self.in_launcher):
                                state_msg = ModelState()
                                state_msg.model_name = 'tennis_ball'
                                state_msg.pose = _pose
                                try:
                                    #resp = self.set_model_state( state_msg )
                                    #rospy.loginfo('Setting Ball Position ='+ str(state_msg.pose.position.x) +' '+ str(state_msg.pose.position.y) +' '+ str( state_msg.pose.position.z) + ' Repsonse = ' + str(resp))
                                    force_lbs = 7.2
                                    force_n = force_lbs * 4.44822 # neuton
                                    self.activate_launcher(_twist, force_n)

                                finally:
                                    pass
                                    # Save off the ball location prior to Launch
                                    try:
                                        model_state = self.get_model_state(ball_name, "")
                                        if(model_state.success):
                                            self.ball_last_position = model_state.pose.position
                                    finally:
                                        pass
                                self.in_launcher = False
                                if(debug_launcher): rospy.loginfo('Launching the Ball! Ball in Launcher = ' + str(self.in_launcher))

                        else:
                            if(self.in_launcher):
                                state_msg = ModelState()
                                state_msg.model_name = ball_name
                                state_msg.pose.position = _pose.position
                                state_msg.pose.position.z += 0.15
                                try:
                                    resp = self.set_model_state( state_msg )
                                    if(debug_ball): rospy.loginfo('Setting Ball Position ='+ str(state_msg.pose.position.x) +' '+ str(state_msg.pose.position.y) +' '+ str( state_msg.pose.position.z) + ' Repsonse = ' + str(resp))
                                finally:
                                    pass


        finally:
            pass

        if(debug_ball):
            try:
                model_state = self.get_model_state(ball_name, "")
                if(model_state.success):
                    _position = model_state.pose.position
                    rospy.loginfo('-> Checked the Ball Position ='+ str(_position.x) +' '+ str(_position.y) +' '+ str( _position.z))
            finally:
                pass

        # Save off the ball location currently
        model_state = self.get_model_state(ball_name, "")
        try:
            if(model_state.success):
                self.ball_current_position = model_state.pose.position
        finally:
            pass


        delta_z = 0.1
        ball_elevation = self.ball_current_position.z
        on_ground = (not self.in_launcher and  ball_elevation < 0.1 and ball_elevation > -0.1)
        if(self.cnt == 50):
            self.launch_ball = True

        elif(on_ground or self.cnt == 150):

            dx = self.ball_last_position.x - self.ball_current_position.x
            dy = self.ball_last_position.y - self.ball_current_position.y
            dz = self.ball_last_position.z - self.ball_current_position.z
            distance = sqrt(dx**2 + dy**2 + dz**2)
            rospy.loginfo('The ball Went ' + str(distance) + ' meters; dx=' + str(dx) + ' dy=' + str(dy) + ' dz=' + str(dz))

            # Auto pick up ball...
            self.in_launcher = True
            self.cnt = 0
        else:
            self.launch_ball = False

        self.cnt += 1

        twist = Twist()



        twist.linear.x = 0.22
        twist.angular.z = 0.11
        self._cmd_pub.publish(twist)
        #rospy.loginfo('Twisting the robot!')




if __name__ == '__main__':
    try:
        print("Starting Program")
        b = BasicEntertrainerController(0.1)
        rospy.spin()

    except rospy.ROSInterruptException:
        pass
