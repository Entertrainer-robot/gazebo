#!/usr/bin/env python

import rospy
#from point_in_polygon import *
from gazebo_msgs.srv import GetWorldProperties, GetModelProperties, GetModelState
import matplotlib as mp
import matplotlib.pyplot as plt
from math import *
from tf.transformations import euler_from_quaternion, quaternion_from_euler
from gazebo_ros.gazebo_interface import spawn_sdf_model_client
from std_msgs.msg import String, Header, Float64MultiArray, Float64, Bool, Int32
from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SetModelState

from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from gazebo_msgs.srv import ApplyBodyWrench
from geometry_msgs.msg import Wrench
from rotation import *
from math import *

from ball_launcher import *

entertrainer_name = "entertrainer"
ball_name = "tennis_ball"
debug_ball = False
debug_launcher = False
debug_position = False

class BasicEntertrainerController(object):

    def __init__(self, rate=0):
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)

        print("Creating object Basic Controller")
        if(rate != 0):
            rospy.init_node('entertrainer_test', log_level=rospy.INFO)

        self.get_world_properties = None
        self.get_model_properties = None
        self.get_model_state = None
        self.ball_launcher = BallLauncher()
        self.cnt = 0
        self.current_num_balls = 3
        self.launch_ball = False
        self.in_launcher = True
        self.ball_last_position = None
        self.ball_current_position = None
        self.objects = {}
        if(rate != 0):
            update_timer = rospy.Timer(rospy.Duration(rate), self.basic_movement)

    def get_proxy_handles(self):
        if self.get_world_properties is None:
            try:
                # Handle for world properties update function
                rospy.wait_for_service('/gazebo/get_world_properties', timeout=2)
                self.get_world_properties = rospy.ServiceProxy('/gazebo/get_world_properties', GetWorldProperties)
            except rospy.ROSException:
                print('/gazebo/get_world_properties service is unavailable')
        if self.get_model_properties is None:
            try:
                # Handle for retrieving model properties
                rospy.wait_for_service('/gazebo/get_model_properties',timeout=0.1)
                self.get_model_properties = rospy.ServiceProxy('/gazebo/get_model_properties', GetModelProperties)
            except rospy.ROSException:
                print('/gazebo/get_model_properties service is unavailable')
        if self.get_model_state is None:
            try:
               # Handle for retrieving model properties
                rospy.wait_for_service('/gazebo/get_joint_properties',timeout=0.1)
                self.get_model_state = rospy.ServiceProxy('/gazebo/get_model_state', GetModelState)
            except rospy.ROSException:
                print('/gazebo/get_model_properties service is unavailable')

        self.ball_launcher.get_proxy_handles()



    def basic_movement(self, event=None):
        self.get_proxy_handles()

        _position = None
        _twist = None
        _pose = None

        try:
            msg_world = self.get_world_properties()
            if(msg_world.success):
                model_properties = self.get_model_properties(entertrainer_name)
                if(model_properties.success):
                    model_state = self.get_model_state(entertrainer_name, "")
                    if(model_state.success):
                        _pose = model_state.pose
                        _position = model_state.pose.position
                        _twist = model_state.pose.orientation
                        if(debug_position): rospy.loginfo('Position ='+ str(_position.x) +' '+ str(_position.y) +' '+ str( _position.z))
                        txyz = calc_euler_from_quaternion(_twist)

                        self.ball_launcher.update_cycle(txyz, _pose)

        finally:
            pass

#        if(debug_ball):
#            try:
#                model_state = self.get_model_state(ball_name, "")
#                if(model_state.success):
#                    _position = model_state.pose.position
#                    rospy.loginfo('-> Checked the Ball Position ='+ str(_position.x) +' '+ str(_position.y) +' '+ str( _position.z))
#            finally:
#                pass

#        # Save off the ball location currently
#        model_state = self.get_model_state(ball_name, "")
#        try:
#            if(model_state.success):
#                self.ball_current_position = model_state.pose.position
#        finally:
#            pass


#        delta_z = 0.1
#        ball_elevation = self.ball_current_position.z
#        on_ground = (not self.in_launcher and  ball_elevation < 0.1 and ball_elevation > -0.1)
#        if(self.cnt == 50):
#            self.launch_ball = True
#
#        elif(on_ground or self.cnt == 150):
#
#            dx = self.ball_last_position.x - self.ball_current_position.x
#            dy = self.ball_last_position.y - self.ball_current_position.y
#            dz = self.ball_last_position.z - self.ball_current_position.z
#            distance = sqrt(dx**2 + dy**2 + dz**2)
#            rospy.loginfo('The ball Went ' + str(distance) + ' meters; dx=' + str(dx) + ' dy=' + str(dy) + ' dz=' + str(dz))

            # Auto pick up ball...
#            self.in_launcher = True
#            self.cnt = 0
#        else:
#            self.launch_ball = False

#        self.cnt += 1

        twist = Twist()



        twist.linear.x = 0.22
        twist.angular.z = 0.11
        self._cmd_pub.publish(twist)
        #rospy.loginfo('Twisting the robot!')




if __name__ == '__main__':
    try:
        print("Starting Program")
        b = BasicEntertrainerController(0.1)
        rospy.spin()

    except rospy.ROSInterruptException:
        pass
